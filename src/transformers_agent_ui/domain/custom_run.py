"""Custom run method for the HF Agent"""
# pylint: disable=line-too-long
# Should be kept aligned with the HF source code
from __future__ import annotations

import ast
from typing import Callable, Dict

from transformers.tools.agents import (
    clean_code_for_run,
    get_tool_creation_code,
    resolve_tools,
)
from transformers.tools.python_interpreter import InterpretorError, evaluate_ast

from transformers_agent_ui.domain.run_output import RunOutput


# Source: transformers/tools/python_interpreter.py
def evaluate(code: str, tools: Dict[str, Callable], state=None):
    """
    Evaluate a python expression using the content of the variables stored in a state and only
    evaluating a given set of functions.

    This function will recurse through the nodes of the tree provided.

    Args:
        code (`str`):
            The code to evaluate.
        tools (`Dict[str, Callable]`):
            The functions that may be called during the evaluation. Any call to another function
            will fail with an `InterpretorError`.
        state (`Dict[str, Any]`):
            A dictionary mapping variable names to values. The `state` should contain the initial
            inputs but will be updated by this function to contain all variables as they are
            evaluated.
    """
    expression = ast.parse(code)
    if state is None:
        state = {}
    result = None
    for idx, node in enumerate(expression.body):
        try:
            line_result = evaluate_ast(node, state, tools)
        except InterpretorError as exc:
            msg = f"Evaluation of the code stopped at line {idx} before the end because of the following error:\n{exc}"

            raise InterpretorError(msg) from exc

        if line_result is not None:
            result = line_result

    return result


# Source: transformers/tools/agents.py
def run(agent, task, *, remote=False, run_output: RunOutput | None = None, **kwargs) -> RunOutput:
    """
    Sends a request to the agent.

    Args:
        task (`str`): The task to perform
        remote (`bool`, *optional*, defaults to `False`):
            Whether or not to use remote tools (inference endpoints) instead of local ones.
        kwargs:
            Any keyword argument to send to the agent when evaluating the code.
    """
    if not run_output:
        run_output = RunOutput()
    else:
        run_output.param.update(
            value="Running ...",
            prompt="...",
            explanation="...",
            code="...",
        )

    run_output.prompt = agent.format_prompt(task)
    result = agent.generate_one(run_output.prompt, stop=["Task:"])

    run_output.explanation, code = clean_code_for_run(result)
    print(f"==Explanation from the agent==\n{run_output.explanation}")
    if code is not None:
        run_output.code = (
            get_tool_creation_code(code, agent.toolbox, remote=remote)
            + "# Exception line count starts below\n\n"
            + code
        )
        print(f"\n\n==Code generated by the agent==\n{code}")
        print("\n\n==Result==")
        agent.cached_tools = resolve_tools(
            code, agent.toolbox, remote=remote, cached_tools=agent.cached_tools
        )
        run_output.value = evaluate(code, agent.cached_tools, state=kwargs.copy())
    return run_output
